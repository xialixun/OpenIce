/*
FILE: openfire_sim.c

DESCRIPTION: openfire_sim is a C simulator for the OpenFire processor.  It
is not cycle accurate.  The program reads in a ROM file (a text file where each
line is an instruction in hex) that is generated by the openfire_util.pl script.
The simulator produces debug statements describing the result of each instruction
in a format identical to openfire_top_sim.v.  Verification can be accomplished
by comparing the output of openfire_sim to a verilog simulation of 
openfire_top_sim.v using the same ROM file as input. 

WARNING! The simulator is very simplistic.  (I am not a programmer.)
 
AUTHOR: 
Stephen Douglas Craven
Configurable Computing Lab
Virginia Tech
scraven@vt.edu

REVISION HISTORY:
Revision 0.2, 8/17/2005 SDC
Initial release

COPYRIGHT:
Copyright (c) 2005 Stephen Douglas Craven

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in 
the Software without restriction, including without limitation the rights to 
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies 
of the Software, and to permit persons to whom the Software is furnished to do 
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE 
SOFTWARE.
*/

#include <stdio.h>
#include <string.h>

void HexPrint (unsigned char *digest, int length)
{
  unsigned int i;
  
  for (i = 0; i < length; i++)
    printf ("%02x", digest[length - 1 - i]);
}

int string_to_hex(char input[10])
{
	char *tmp;
	int i, j, sum, power;
	char *compare;
	char *COMPARE;
	
	compare = "abcdef123456789";
	COMPARE = "ABCDEF";
	
	tmp = "0x";
	if(memcmp(&input[0], &tmp[0], 2) != 0) {
		printf("Error! Breakpoint is not in Hex! %s\n", input);
		exit(0);
	}
	sum = 0;
	power = 1;
	tmp = "a";
	for(i = strlen(input) - 1; i > 1; i--) {
		if(memcmp(&input[i], &compare[0], 1) == 0 | memcmp(&input[i], &COMPARE[0], 1) == 0)
			sum = sum + 10 * power;
		else if(memcmp(&input[i], &compare[1], 1) == 0 | memcmp(&input[i], &COMPARE[1], 1) == 0)
			sum = sum + 11 * power;
		else if(memcmp(&input[i], &compare[2], 1) == 0 | memcmp(&input[i], &COMPARE[2], 1) == 0)
			sum = sum + 12 * power;
		else if(memcmp(&input[i], &compare[3], 1) == 0 | memcmp(&input[i], &COMPARE[3], 1) == 0)
			sum = sum + 13 * power;
		else if(memcmp(&input[i], &compare[4], 1) == 0 | memcmp(&input[i], &COMPARE[4], 1) == 0)
			sum = sum + 14 * power;
		else if(memcmp(&input[i], &compare[5], 1) == 0 | memcmp(&input[i], &COMPARE[5], 1) == 0)
			sum = sum + 15 * power;
		else if(memcmp(&input[i], &compare[6], 1) == 0)
			sum = sum + 1 * power;
		else if(memcmp(&input[i], &compare[7], 1) == 0)
			sum = sum + 2 * power;
		else if(memcmp(&input[i], &compare[8], 1) == 0)
			sum = sum + 3 * power;
		else if(memcmp(&input[i], &compare[9], 1) == 0)
			sum = sum + 4 * power;
		else if(memcmp(&input[i], &compare[10], 1) == 0)
			sum = sum + 5 * power;
		else if(memcmp(&input[i], &compare[11], 1) == 0)
			sum = sum + 6 * power;
		else if(memcmp(&input[i], &compare[12], 1) == 0)
			sum = sum + 7 * power;
		else if(memcmp(&input[i], &compare[13], 1) == 0)
			sum = sum + 8 * power;
		else if(memcmp(&input[i], &compare[14], 1) == 0)
			sum = sum + 9 * power;
		power = power * 16;
	}
	return(sum);
}

void print_options(char *command_name)
{
	printf("\n%s - OpenFire Instruction Set Simulator\n\n", command_name);
	printf("	Usage: %s <-f rom_file> <-b breakpoint> <-c cycle_count>\n", command_name);
	printf("		where:\n");
	printf("		rom_file is a Microblaze text memory image from openfire_util.pl\n");
	printf("		breakpoint is a hex address (0x####)\n");
	printf("		cycle_count is the decimal number of cycles to run\n\n");
	exit(0);
}



int main(int argc, char* argv[]) {

FILE	*FILE_PTR;
int	memory[32768];
unsigned char	tmp_buffer[10], tmp1, tmp2, tmp3, tmp4;
unsigned char	*char_ptr;
int	reg_file[32];
int	PC;
int	MSR;
int 	i, k, tmp;
int	counter;
int	instruction;
int 	opcode;
int	regA;
int	regA_addr;
int	regB;
int	regB_addr;
int	regD;
int	regD_addr;
int	imm;
int	carry_in;
int	branch_delay_slot;
int	PC_branch;
int	new_reg_value;
int 	imm_valid;
int	mem_addr;
int	previous_imm;
int	load;
int 	branch;
int	flag;
int 	break_point;
int	store;
int	output_addr;
int	stop_counter;
char	filename[128] = "instr.rom";
char	output_file[128];
long long	alu_result;

stop_counter = 5000;
break_point = 0x3b8;
FILE_PTR = fopen("instr.rom", "r");

output_addr = 0xFFFFFFFF;
for( i=1; i < argc; i = i + 2) {
	if((strcmp(argv[i], "-h") == 0) | (strcmp(argv[i], "--help") == 0))
		print_options(argv[0]);
	else if(strcmp(argv[i], "-f") == 0) {
		strcpy(filename, argv[i+1]);
		FILE_PTR = fopen(filename, "r");
	}
	else if(strcmp(argv[i], "-c") == 0)
		stop_counter = atoi(argv[i+1]);
	else if(strcmp(argv[i], "-b") == 0) {
		break_point = string_to_hex(argv[i+1]);
	}
	else if(strcmp(argv[i], "-o") == 0) {
		strcpy(output_file,argv[i+1]);
	}
	else if(strcmp(argv[i], "-a") == 0) {
		output_addr = string_to_hex(argv[i+1]);
	}
	else
		print_options(argv[0]);
}

/* Load Memory */
if(!FILE_PTR)
{
    printf("\n*** Could not open file %s.  Giving up. ***\n", filename);
    print_options(argv[0]);
    return 0;
}
fgets(tmp_buffer, 10, FILE_PTR);
i = 0;
while(feof(FILE_PTR) == 0)
{
	sscanf(tmp_buffer, "%x", &memory[i]);
	fgets(tmp_buffer, 10, FILE_PTR);
	i++;
}


/* Initialize HW */
PC = 0;
MSR = 0;
for(i = 0; i < 32; i++)
	reg_file[i] = 0;

branch_delay_slot = 0;
counter = 0;
imm_valid = 0;
while(counter < stop_counter) {
	new_reg_value = 0;
	branch = 0;
	mem_addr = 0x666;
	load = 0;
	carry_in = 0;
	store = 0;
	instruction = memory[PC>>2];
	opcode = (instruction >> 26) & 0x3F;
	regD_addr = (instruction >> 21) & 31;
	regA_addr = (instruction >> 16) & 31;
	regB_addr = (instruction >> 11) & 31;		
	regD = reg_file[(instruction >> 21) & 31];
	regA = reg_file[(instruction >> 16) & 31];
	regB = reg_file[(instruction >> 11) & 31];
	imm = instruction & 0xFFFF;
	if(imm_valid == 1)
		imm = (previous_imm << 16) | imm;
	else
		if((imm & 0x8000) == 0x8000)
			imm = imm | 0xFFFF0000;
		else
			imm = imm & 0xFFFF;
	imm_valid = 0;
	/* ADD, SUB */
	if((opcode & 48) == 0) { /* 00XXXX */
		carry_in = 0;
		if((opcode & 1) == 1) {
			regA = ~regA;
			carry_in = 1;
		}
		if((opcode & 2) == 2) {
			carry_in = (MSR & 4) >> 2;
		}
		if((opcode & 8) == 8) {
			regB = imm;
		}
		alu_result =(long long) regA + (long long) regB + (long long) carry_in;
		reg_file[regD_addr] = alu_result & 0xffffffff;
		new_reg_value = 1;
		if((opcode & 4) == 0) { // K_bit not set -> update carry
		 	if(((alu_result >> 32) & 1) != 0)
				MSR = MSR | 0x4;
			else
				MSR = MSR & 0xFFFFFFFB;
		}
		if((imm & 1) == 1 & (opcode == 5)) { /* CMP/CMPU */
			if((imm & 2) == 2) { /* CMPU */
				if ( (unsigned int) ~regA > (unsigned int) regB)
					reg_file[regD_addr] = reg_file[regD_addr] | 0x80000000;
				else
					reg_file[regD_addr] = reg_file[regD_addr] & 0x7FFFFFFF;				
			} else { /* CMP */
				if ( (int) ~regA > (int) regB)
					reg_file[regD_addr] = reg_file[regD_addr] | 0x80000000;
				else
					reg_file[regD_addr] = reg_file[regD_addr] & 0x7FFFFFFF;
			}
		}
	}
	/* MUL / MULI */
	if((opcode & 55) == 16) { /* 01X000 */
		if((opcode & 8) == 8) {
			regB = imm;
		}
		alu_result = (long long) regA * (long long) regB;
		reg_file[regD_addr] = alu_result & 0xffffffff;
		new_reg_value = 1;
	}		
	/* Logical Functions */
	if(opcode == 32) { /* OR */
		new_reg_value = 1;
		reg_file[regD_addr] = regA | regB;
	}
	if(opcode == 33) { /* AND */
		new_reg_value = 1;
		reg_file[regD_addr] = regA & regB;
	}
	if(opcode == 34) { /* XOR */
		reg_file[regD_addr] = regA ^ regB;
		new_reg_value = 1;
	}
	if(opcode == 35) { /* ANDN */
		new_reg_value = 1;
		reg_file[regD_addr] = regA & ~regB;
	}
	if((opcode == 36) & (imm == 1)) { /* SRA */
		if((regA & 0x1) == 1)
			MSR = MSR | 0x4;
		else
			MSR = MSR & 0xFFFFFFFB;
		reg_file[regD_addr] = regA;
		reg_file[regD_addr] = reg_file[regD_addr] & 0x80000000;
		reg_file[regD_addr] = reg_file[regD_addr] | (regA >> 1);
		new_reg_value = 1;
	}
	if((opcode == 36) & (imm == 33)) { /* SRC */
		if((regA & 0x1) == 1)
			MSR = MSR | 0x4;
		else
			MSR = MSR & 0xFFFFFFFB;
		reg_file[regD_addr] = MSR & 0x80000000; /* use CC bit */
		reg_file[regD_addr] = reg_file[regD_addr] | (regA >> 1);
		new_reg_value = 1;
	}
	if((opcode == 36) & (imm == 65)) { /* SRL */
		if((regA & 0x1) == 1)
			MSR = MSR | 0x4;
		else
			MSR = MSR & 0xFFFFFFFB;
		reg_file[regD_addr] = (regA >> 1);
		new_reg_value = 1;
	}
	if((opcode == 36) & (imm == 96)) { /* SEXT8 */	
		if((regA & 128) == 128)
			reg_file[regD_addr] = regA | 0xFFFFFF00;
		else
			reg_file[regD_addr] = regA & 0xFF;
		new_reg_value = 1;
	}
	if((opcode == 36) & (imm == 97)) { /* SEXT16 */	
		if((regA & 0x8000) == 0x8000) {
			reg_file[regD_addr] = regA | 0xFFFF0000;
		}
		else
			reg_file[regD_addr] = regA & 0xFFFF;
		new_reg_value = 1;
	}
	if((opcode == 38) & ((imm & 2047) == 0)){ /* Branches */
		if(regA_addr == 0) { /* BR */
			PC_branch = PC + regB;
			branch = 1;
		}
		if(regA_addr == 16) { /* BRD */
			branch_delay_slot = 2;
			PC_branch = PC + regB;
		}
		if(regA_addr == 20) { /* BRLD */
			branch_delay_slot = 2;
			reg_file[regD_addr] = PC;
			new_reg_value = 1;
			PC_branch = PC + regB;
		}
		if(regA_addr == 8) { /* BRA */
			PC_branch = regB;
			branch = 1;
		}
		if(regA_addr == 24) { /* BRAD */
			branch_delay_slot = 1;
			PC_branch = regB;
			branch = 1;
		}
		if(regA_addr == 28) { /* BRALD */
			branch_delay_slot = 2;
			reg_file[regD_addr] = PC;
			new_reg_value = 1;
			PC_branch = regB;
		}
		if(regA_addr == 12) { /* BRK */
			reg_file[regD_addr] = PC;
			new_reg_value = 1;
			PC_branch = regB;
			branch = 1;
		}
	} /* End unconditional branches */
	if(opcode == 39 & ((imm & 2047) == 0)) { /* Conditional Branches */
		if(regD_addr == 0 | regD_addr == 16) { /* BEQ */
			if(regA == 0) {
				PC_branch = PC + regB;
				branch = 1;
			}
		}
		if(regD_addr == 1 | regD_addr == 17) { /* BNE */
			if(regA != 0) {
				PC_branch = PC + regB;
				branch = 1;
			}
		}
		if(regD_addr == 2 | regD_addr == 18) { /* BLT */
			if(regA < 0) {
				PC_branch = PC + regB;
				branch = 1;
			}
		}
		if(regD_addr == 3 | regD_addr == 19) { /* BLE */
			if(regA <= 0) {
				PC_branch = PC + regB;
				branch = 1;
			}
		}
		if(regD_addr == 4 | regD_addr == 20) { /* BGT */
			if(regA > 0) {
				PC_branch = PC + regB;
				branch = 1;
			}
		}
		if(regD_addr == 5 | regD_addr == 21) { /* BGE */
			if(regA >= 0) {
				PC_branch = PC + regB;
				branch = 1;
			}
		}
		if(branch == 1 & regD_addr > 15) {/* Handles all delayed conditional branches */
			branch_delay_slot == 2;
			branch = 0;
		}
	} /* End Conditional Branches */

	/* Logical Functions with IMMs*/
	if(opcode == 40) { /* ORI */
		new_reg_value = 1;
		reg_file[regD_addr] = regA | imm;
	}
	if(opcode == 41) { /* ANDI */
		new_reg_value = 1;
		reg_file[regD_addr] = regA & imm;
	}
	if(opcode == 42) { /* XORI */
		reg_file[regD_addr] = regA ^ imm;
		new_reg_value = 1;
	}
	if(opcode == 43) { /* ANDNI */
		new_reg_value = 1;
		reg_file[regD_addr] = regA & ~imm;
	}
	if(opcode == 44) { /* IMM */
		imm_valid = 1;
		previous_imm = imm;
	}
	if(opcode == 45 & (regD_addr == 16 | regD_addr == 18)) { /* Returns */
		branch_delay_slot = 2;
		PC_branch = regA + imm;
	}
	
	if(opcode == 46){ /* Branches with IMM*/
		if(regD_addr == 0 & regA_addr == 0) { /* BRI */
			PC_branch = PC + imm;
			branch = 1;
		}
		if(regD_addr == 0 & regA_addr == 16) { /* BRID */
			branch_delay_slot = 2;
			PC_branch = PC + imm;
		}
		if(regA_addr == 20) { /* BRLID */
			branch_delay_slot = 2;
			reg_file[regD_addr] = PC;
			new_reg_value = 1;
			PC_branch = PC + imm;
		}
		if(regD_addr == 0 & regA_addr == 8) { /* BRAI */
			PC_branch = imm;
			branch = 1;
		}
		if(regA_addr == 24 & regD == 0) { /* BRAID */
			branch_delay_slot = 2;
			PC_branch = imm;
		}
		if(regA_addr == 28) { /* BRALID */
			branch_delay_slot = 2;
			reg_file[regD_addr] = PC;
			new_reg_value = 1;
			PC_branch = imm;
		}
		if(regA_addr == 12) { /* BRKI */
			reg_file[regD_addr] = PC;
			new_reg_value = 1;
			PC_branch = imm;
			branch = 1;
		}
	} /* End unconditional branches */
	if(opcode == 47) { /* Conditional Branches with IMMs*/
		if(regD_addr == 0 | regD_addr == 16) { /* BEQI */
			if(regA == 0) {
				PC_branch = PC + imm;
				branch = 1;
			}
		}
		if(regD_addr == 1 | regD_addr == 17) { /* BNEI */
			if(regA != 0) {
				PC_branch = PC + imm;
				branch = 1;
			}
		}
		if(regD_addr == 2 | regD_addr == 18) { /* BLTI */
			if(regA < 0) {
				PC_branch = PC + imm;
				branch = 1;
			}
		}
		if((regD_addr == 3) | (regD_addr == 19)) { /* BLEI */
			if(regA <= 0) {
				PC_branch = PC + imm;
				branch = 1;
			}
		}
		if(regD_addr == 4 | regD_addr == 20) { /* BGTI */
			if(regA > 0) {
				PC_branch = PC + imm;
				branch = 1;
			}
		}
		if(regD_addr == 5 | regD_addr == 21) { /* BGEI */
			if(regA >= 0) {
				PC_branch = PC + imm;
				branch = 1;
			}
		}
		if((branch == 1) & (regD_addr > 15)) {/* Handles all delayed conditional branches */
			branch_delay_slot = 2;
			branch = 0;
		}
	} /* End Conditional Branches */
	
	
	
	/* Load / Store instructions */
	if(opcode == 48) { /* LBU */
		load = 1;
		mem_addr = (regA + regB) >> 2;
		if (mem_addr >= 32768) {
			printf("MEMORY OUT OF RANGE @ PC: 0x%x\n", PC);
			exit(0);
		}
		//reg_file[regD_addr] = memory[(regA + regB) >> 2] & (0xFF000000 >> 8*((regA + regB) & 3));
		reg_file[regD_addr] = 0xFF & (memory[(regA + regB) >> 2] >> (8 * (3 - ((regA + regB) & 3))));
	}
	if(opcode == 49) { /* LHU */
		load = 1;
		mem_addr = (regA + regB) >> 2;
		if (mem_addr >= 32768) {
			printf("MEMORY OUT OF RANGE @ PC: 0x%x\n", PC);
			exit(0);
		}
		//reg_file[regD_addr] = memory[(regA + regB) >> 2] & (0xFFFF0000 >> (8 * ((regA + regB) & 3)));
		//printf("DEBUG: (regA + regB) & 3 is %d\n", ((regA + regB) & 3));
		//printf("DEBUG: memory fns is 0x%x\n", mem_addr);
		reg_file[regD_addr] = 0xFFFF & (memory[(regA + regB) >> 2] >> (8 * (2 - ((regA + regB) & 3))));
	}
	if(opcode == 50) { /* LW */
		load = 1;
		mem_addr = (regA + regB) >> 2;
		if (mem_addr >= 32768) {
			printf("MEMORY OUT OF RANGE @ PC: 0x%x\n", PC);
			exit(0);
		}
		reg_file[regD_addr] = memory[(regA + regB) >> 2];
	}
	if(opcode == 56) { /* LBUI */
		load = 1;
		mem_addr = (regA + imm) >> 2;
		if (mem_addr >= 32768) {
			printf("MEMORY OUT OF RANGE @ PC: 0x%x\n", PC);
			exit(0);
		}
		//reg_file[regD_addr] = memory[(regA + imm) >> 2] & (0xFF000000 >> 8*((regA + imm) & 3));
		reg_file[regD_addr] = 0xFF & (memory[(regA + imm) >> 2] >> (8 * (3 - ((regA + imm) & 3))));		
	}
	if(opcode == 57) { /* LHUI */
		load = 1;
		mem_addr = (regA + imm) >> 2;
		if (mem_addr >= 32768) {
			printf("MEMORY OUT OF RANGE @ PC: 0x%x\n", PC);
			exit(0);
		}
		//reg_file[regD_addr] = memory[(regA + imm) >> 2] & (0xFFFF0000 >> 8*((regA + imm) & 3));
		reg_file[regD_addr] = 0xFFFF & (memory[(regA + imm) >> 2] >> (8 * (2 - ((regA + imm) & 3))));
	}
	if(opcode == 58) { /* LWI */
		load = 1;
		mem_addr = (regA + imm) >> 2;
		if (mem_addr >= 32768) {
			printf("MEMORY OUT OF RANGE @ PC: 0x%x\n", PC);
			exit(0);
		}
		reg_file[regD_addr] = memory[(regA + imm) >> 2];
	}
	if(opcode == 52) { /* SB */
		store = 1;
		mem_addr = (regA + regB) >> 2;
		if (mem_addr >= 32768) {
			printf("MEMORY OUT OF RANGE @ PC: 0x%x\n", PC);
			exit(0);
		}
		if (((regA + regB) & 3) == 0) {
			memory[(regA + regB) >> 2] = memory[(regA + regB) >> 2] & 0x00FFFFFF;
			memory[(regA + regB) >> 2] = memory[(regA + regB) >> 2] | ((regD << 24) & 0xFF000000);
		}
		if (((regA + regB) & 3) == 1) {
			memory[(regA + regB) >> 2] = memory[(regA + regB) >> 2] & 0xFF00FFFF;
			memory[(regA + regB) >> 2] = memory[(regA + regB) >> 2] | ((regD << 16) & 0xFF0000);
		}
		if (((regA + regB) & 3) == 2) {
			memory[(regA + regB) >> 2] = memory[(regA + regB) >> 2] & 0xFFFF00FF;
			memory[(regA + regB) >> 2] = memory[(regA + regB) >> 2] | ((regD << 8) & 0xFF00);
		}
		if (((regA + regB) & 3) == 3) {
			memory[(regA + regB) >> 2] = memory[(regA + regB) >> 2] & 0xFFFFFF00;
			memory[(regA + regB) >> 2] = memory[(regA + regB) >> 2] | (regD & 0xFF);
		}
	}
	if(opcode == 53) { /* SH */
		store = 1;
		mem_addr = (regA + regB) >> 2;
		if (mem_addr >= 32768) {
			printf("MEMORY OUT OF RANGE @ PC: 0x\n", PC);
			exit(0);
		}
		if (((regA + regB) & 3) == 0) {
			memory[(regA + regB) >> 2] = memory[(regA + regB) >> 2] & 0xFFFF;
			memory[(regA + regB) >> 2] = memory[(regA + regB) >> 2] | ((regD << 16) & 0xFFFF0000);
		} else {
			memory[(regA + regB) >> 2] = memory[(regA + regB) >> 2] & 0xFFFF0000;
			memory[(regA + regB) >> 2] = memory[(regA + regB) >> 2] | (regD & 0xFFFF);
		}
	}
	if(opcode == 54) { /* SW */
		store = 1;
		//printf("Here\n");
		mem_addr = (regA + regB) >> 2;
		if (mem_addr >= 32768) {
			printf("MEMORY OUT OF RANGE @ PC: 0x\n", PC);
			exit(0);
		}
				//printf("Here mem_addr = %x regD = %x mem = %x\n", mem_addr, regD, memory[mem_addr]);
		memory[mem_addr] = regD;
				//printf("Here\n");
	}
	if(opcode == 60) { /* SBI */
		store = 1;
		mem_addr = (regA + imm) >> 2;
		if (mem_addr >= 32768) {
			printf("MEMORY OUT OF RANGE @ PC: 0x\n", PC);
			exit(0);
		}
		if (((regA + imm) & 3) == 0) {
			memory[(regA + imm) >> 2] = memory[(regA + imm) >> 2] & 0x00FFFFFF;
			memory[(regA + imm) >> 2] = memory[(regA + imm) >> 2] | ((regD << 24) & 0xFF000000);
		}
		if (((regA + imm) & 3) == 1) {
			memory[(regA + imm) >> 2] = memory[(regA + imm) >> 2] & 0xFF00FFFF;
			memory[(regA + imm) >> 2] = memory[(regA + imm) >> 2] | ((regD << 16) & 0xFF0000);
		}
		if (((regA + imm) & 3) == 2) {
			memory[(regA + imm) >> 2] = memory[(regA + imm) >> 2] & 0xFFFF00FF;
			memory[(regA + imm) >> 2] = memory[(regA + imm) >> 2] | ((regD << 8) & 0xFF00);
		}
		if (((regA + imm) & 3) == 3) {
			memory[(regA + imm) >> 2] = memory[(regA + imm) >> 2] & 0xFFFFFF00;
			memory[(regA + imm) >> 2] = memory[(regA + imm) >> 2] | (regD & 0xFF);
		}
	}
	if(opcode == 61) { /* SHI */
		store = 1;
		mem_addr = (regA + imm) >> 2;
		if (mem_addr >= 32768) {
			printf("MEMORY OUT OF RANGE @ PC: 0x\n", PC);
			exit(0);
		}
		if (((regA + imm) & 3) == 0) {
		//printf("Here\n");
			memory[(regA + imm) >> 2] = memory[(regA + imm) >> 2] & 0xFFFF;
			memory[(regA + imm) >> 2] = memory[(regA + imm) >> 2] | ((regD << 16) & 0xFFFF0000);
		} else {
			memory[(regA + imm) >> 2] = memory[(regA + imm) >> 2] & 0xFFFF0000;
			memory[(regA + imm) >> 2] = memory[(regA + imm) >> 2] | (regD & 0xFFFF);
		}
	}
	if(opcode == 62) { /* SWI */
		store = 1;
		mem_addr = (regA + imm) >> 2;
		if (mem_addr >= 32768) {
			printf("MEMORY OUT OF RANGE @ PC: 0x\n", PC);
			exit(0);
		}
		memory[(regA + imm) >> 2] = regD;
	}
	/* End instructions */
	
	if((branch == 1) | (branch_delay_slot == 2)) {
		printf("*** PC: ");
		HexPrint((unsigned char*) &PC, 4);
		printf(" Branching to ");
		HexPrint((unsigned char*)&PC_branch, 4);
		printf("\n");
	}
	
	/* Print on register writes */
	if((new_reg_value == 1) & (instruction != 0x80000000)) {
		printf("*** PC: ");
		HexPrint((unsigned char*)&PC, 4);
		printf(" Writing ");
		HexPrint((unsigned char*)&reg_file[regD_addr], 4);
		printf(" to Register %2i\n", regD_addr);
	}
	//printf("*** PC: %8x Instruction %8x Opcode %d new_reg_value %i\n", PC, instruction, opcode, new_reg_value);
	
	/* Print on Load / Store */
	if(load == 1) {
		//printf("*** PC: %8x Writing %8x to Register %2i from DMEM addr 0x%8x\n", PC, reg_file[regD_addr], regD_addr, mem_addr << 2 );
		tmp = mem_addr << 2;
		//printf("counter = %d, branch_delay_slot = %d ", counter, branch_delay_slot);
		printf("*** PC: ");
		HexPrint((unsigned char*)&PC, 4);
		printf(" Writing ");
		HexPrint((unsigned char*)&reg_file[regD_addr], 4);
		printf(" to Register %2i from DMEM addr 0x", regD_addr);
		HexPrint((unsigned char*)&tmp, 4);
		printf("\n");
	}	
	if(store == 1) {
		//printf("*** PC: %8x Writing %8x to DMEM location 0x%8x\n", PC, memory[mem_addr], mem_addr << 2 );
		tmp = mem_addr << 2;
		printf("*** PC: ");
		HexPrint((unsigned char*)&PC, 4);
		printf(" Writing ");
		HexPrint((unsigned char*)&memory[mem_addr], 4);
		printf(" to DMem location ");
		HexPrint((unsigned char*)&tmp, 4);
		printf("\n");
	}
	if (PC == break_point) {
		//printf("BREAKPOINT! regD = %x regD_addr = %d\n", regD, regD_addr);
		break;		
	}
	
	if (branch_delay_slot == 1) {
		branch_delay_slot = 0;
		PC = PC_branch;
	} else if (branch == 1)
		PC = PC_branch;
	else
		PC = PC + 4;
	if (branch_delay_slot > 1)
		branch_delay_slot = 1;
	counter++;
}

// Write Mem to binary file
if(output_addr != 0xFFFFFFFF) {
	FILE_PTR = fopen(output_file, "w");
	
	/* Load Memory */
	if(!FILE_PTR)
	{
	    printf("Could not open file %s.  Giving up.\n", output_file);
	    return 0;
	}
	char_ptr = (unsigned char*) &memory[(output_addr>>2)];
	flag = 0;
	while (char_ptr < ((unsigned char*) ( &memory[(output_addr>>2)] + 2200/4))) {
		tmp1 = *char_ptr;
		char_ptr++;
		tmp2 = *char_ptr;
		char_ptr++;
		tmp3 = *char_ptr;
		char_ptr++;
		tmp4 = *char_ptr;
		char_ptr++;
		if(flag)
			fprintf(FILE_PTR, "%c%c%c%c", tmp4, tmp3, tmp2, tmp1);
		else {
			if((output_addr & 3) == 0)
				fprintf(FILE_PTR, "%c%c%c%c", tmp4, tmp3, tmp2, tmp1);
			if((output_addr & 3) == 1)
				fprintf(FILE_PTR, "%c%c%c", tmp3, tmp2, tmp1);
			if((output_addr & 3) == 2)
				fprintf(FILE_PTR, "%c%c", tmp2, tmp1);
			if((output_addr & 3) == 3)
				fprintf(FILE_PTR, "%c", tmp1);
		}
		flag = 1;
	}
	fclose(FILE_PTR);

}
}

